BFS-> BFS is a traversing algorithm where you should start traversing from a selected node (source or starting node) and traverse the graph layerwise thus exploring the neighbour nodes (nodes which are directly connected to source node). You must then move towards the next-level neighbour nodes.
$
DFS-> The DFS algorithm is a recursive algorithm that uses the idea of backtracking. It involves exhaustive searches of all the nodes by going ahead, if possible, else by backtracking.
$
Hill Climbing-> Hill Climbing algorithm is a local search algorithm which continuously moves in the direction of increasing elevation/value. The best possible solution is the highest value/elevation it can obtain. Since this algorithm never looks beyond the immediate neighbours, it is prone to finding "a mountain peak" and getting stuck there, for it terminates when it reaches the highest value among neighbours.
$
Beam-> The local beam search algorithm keeps track of a certain amount (k) of states rather than just one. It begins with k paths coming from the start node. At each step, it looks at all possible neighbors. If any one is a goal, the algorithm halts. Otherwise, it selects the k best successors (the k paths most likely to take you to the goal the fastest) from the complete list and repeats.
$
Branch and Bound-> The general idea of B&B is a BFS-like search for the optimal solution, but not all nodes get expanded (i.e., their children generated). Rather, a carefully selected criterion determines which node to expand and when, and another criterion tells the algorithm when an optimal solution has been found.
$
A*-> A* is a pathfinding algorithm that aims to find the shortest possible path between point A and point B. It has 3 variables. g - the cost of moving from the first cell to the current cell. h - the estimated cost of moving from current cell to the final one. f - the sum of g+h. So it basically stores the cost of the current path, sums it up with an estimation of how costly it'll be to get to the end goal and queues it up, sorting always from the shortest probable path to the longest.